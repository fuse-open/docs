{
  "entity": {
    "location": {
      "namespaceTitle": "Fuse.Input",
      "namespaceUri": "fuse/input",
      "packageName": "Fuse.Nodes",
      "packageVersion": "1.8.0-rc2"
    },
    "parameters": [
      {
        "name": "forced",
        "href": "uno/bool",
        "title": "bool",
        "fullyQualifiedTitle": "bool"
      }
    ],
    "id": {
      "id": "fuse/input/igesture/onlostcapture_f0c97f29",
      "parentId": "fuse/input/igesture",
      "type": "Method",
      "modifiers": [
        "public",
        "abstract"
      ]
    },
    "uri": {
      "idUri": "fuse/input/igesture/onlostcapture_f0c97f29",
      "href": "fuse/input/igesture/onlostcapture_f0c97f29"
    },
    "titles": {
      "pageTitle": "IGesture.OnLostCapture Method (bool)",
      "navigationTitle": "OnLostCapture Method (bool)",
      "fullTitle": "Fuse.Input.IGesture.OnLostCapture",
      "indexTitle": "OnLostCapture(bool)",
      "fullyQualifiedIndexTitle": "Fuse.Input.IGesture.OnLostCapture(bool)"
    },
    "syntax": {
      "uno": "public abstract voidOnLostCapture(bool forced) {}"
    },
    "comment": {
      "brief": "Called whenever a previous capture is lost, soft or hard.",
      "full": "Called whenever a previous capture is lost, soft or hard.\n\nIt must be expected that this can be called at anytime. An IGesture implementation must be able to deal with lost captures at the start, middle, or end of a gesture, even if it's started making visual changes.",
      "attributes": {
        "parameters": [
          {
            "name": "forced",
            "description": "False if the capture is lost due to a cancel request by the gesture. True otherwise, in cases such as it losing priority or the app losing focus."
          }
        ]
      }
    }
  },
  "tableOfContents": {}
}